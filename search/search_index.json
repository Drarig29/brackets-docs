{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to the documentation of these two packages:</p> <ul> <li>brackets-manager.js</li> <li>brackets-viewer.js</li> </ul> <p>Both libraries can be used separately and you can also use the manager only.</p> <p>All the shared types are shipped in this package:</p> <ul> <li>brackets-model</li> </ul> <p>Total number of stars: 0</p>"},{"location":"#reference","title":"Reference","text":"<p>You can find detailed technical documentation in the \"Reference\" section.</p>"},{"location":"about/","title":"About","text":"<p>All these libraries were initially created for the Nantarena, a LAN party organized by a French school, in which I was a CS:GO server admin.</p> <p>We wanted to move away from the public \u2013 and not open source \u2013 solution we were using to manage the tournaments.</p> <p>We finally didn't take the step, but I still enjoy this project and the (small) popularity it's starting to have.</p> <p>Don't mind to file an issue or start a discussion in the relevant GitHub repo! </p> <p>All of this work is under the MIT License.</p>"},{"location":"faq/","title":"FAQ","text":"<p>This page contains frequently asked questions and answers.</p>"},{"location":"faq/#why-do-i-need-a-tournamentid","title":"Why do I need a <code>tournamentId</code>?","text":"<p>Although the manager doesn't manipulate the tournaments (no CRUD operation on a \"tournament\" table), you'll need to give a <code>tournamentId</code> to create a stage because you can have multiple stages per tournament.</p> <p>For instance, you could have:</p> <ul> <li>A round-robin stage (32 participants)</li> <li>A high-tier double elimination stage (16 best participants)</li> <li>A low-tier double elimination stage (the rest of the participants)</li> </ul> <p>And thanks to that, the participants in the database can be linked to a specific tournament.</p> <p>If you don't handle multiple tournaments or if you have a single stage at a time, just choose any number to pass to the manager e.g. <code>0</code> or <code>1</code>.</p>"},{"location":"faq/#how-to-handle-two-stage-tournaments-eg-round-robin-followed-by-elimination","title":"How to handle two-stage tournaments? (e.g. round-robin followed by elimination)","text":"<p>Related issue: brackets-manager.js#206</p> <p>Q: Should I create the two stages at the same time or should I wait until the end of the round robin stage to create the second stage?</p> <p>A: As you prefer. If you already know the size of your second stage, you can create it at the same time as the first stage and specify a <code>size</code> when calling <code>manager.create.stage()</code>.</p> <p>Q: How do I tell the round-robin stage that the first N participants of each group should be qualified?</p> <p>A: It's not possible to configure this on the round-robin stage because it requires a <code>rankingFormula</code> function, which can't be serialized in stage settings.</p> <p>But you can pass a <code>rankingFormula</code> and <code>maxQualifiedParticipantsPerGroup</code> to <code>manager.get.finalStandings()</code>.</p> <p>Q: How do I create the elimination stage and tell it to take the first N participants of each group as seeding?</p> <p>A: This is not supported by the manager, so you have to implement it yourself.</p> <p>You could implement it in the following way:</p> <ul> <li>Every time you update a match, call <code>manager.get.currentRound()</code>. If it returns <code>null</code>, then the round-robin stage is complete.</li> <li>Call <code>manager.get.finalStandings()</code> to get the qualified participants of the round-robin stage.</li> <li>If the elimination stage is already created, call <code>manager.update.seeding()</code> to update the seeding with the qualified participants.<ul> <li>If it's not created yet, call <code>manager.create.stage()</code> with the qualified participants as seeding.</li> </ul> </li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Let's set up the most common use-case.</p> <p>The manager creates the needed data to store the structure of the tournament, all the matches and their results.</p> <p>Then, it is used to update the results during the progress of the tournament.</p> <p>The viewer can display the state of the tournament at any point of its lifetime.</p>"},{"location":"getting-started/#choosing-the-storage","title":"Choosing the storage","text":"<p>First, you need to choose what type of storage you will continue with.</p> <p>The most common choices are:</p> <ul> <li>A JSON database, stored in a file</li> <li>An in-memory database, stored in a simple variable</li> </ul> <p>To use a storage, you need to use a <code>CrudInterface</code> implementation.</p> <p>You will find in the <code>brackets-storage</code> repository a list of NPM packages providing such implementations.</p> <p>If you can't find an implementation for the storage you want to use, you will have to implement it yourself. See Storage for more information.</p>"},{"location":"getting-started/#using-the-manager","title":"Using the manager","text":"<p>First, create an instance of the storage implementation you chose before:</p> <pre><code>const { JsonDatabase } = require('brackets-json-db');\nconst storage = new JsonDatabase();\n</code></pre> <p>Then, create a manager by passing the storage implementation to the constructor:</p> <pre><code>const { BracketsManager } = require('brackets-manager');\nconst manager = new BracketsManager(storage);\n</code></pre> <p>Now, you can start creating tournament stages with <code>manager.create.stage()</code>!</p> <pre><code>await manager.create.stage({\n    name: 'Example stage',\n    tournamentId: 0, // (1)\n    type: 'single_elimination',\n    seeding: [\n        'Team 1',\n        'Team 2',\n        'Team 3',\n        'Team 4',\n        'Team 5',\n        'Team 6',\n        'Team 7',\n        'Team 8',\n    ],\n});\n</code></pre> <ol> <li>Why do you need <code>tournamentId</code>? See the answer in the FAQ.</li> </ol> <p>For more information about the vocabulary (particularly the word \"stage\"), see the Glossary.</p> <p>For an explanation about how the seeding works, see Seeding.</p> <p>For other questions, see FAQ.</p>"},{"location":"getting-started/#using-the-viewer","title":"Using the viewer","text":"<p>The easiest way to use the viewer is to import it via the CDN links.</p> <p>Drop this where it's the most suitable in your project:</p> <pre><code>&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/brackets-viewer@latest/dist/brackets-viewer.min.css\" /&gt;\n&lt;script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/brackets-viewer@latest/dist/brackets-viewer.min.js\"&gt;&lt;/script&gt;\n</code></pre> <p>Now you should have access to <code>window.bracketsViewer</code>.</p> <p>After this, you will need data. Here, either you make an API yourself or you can use <code>json-server</code> to create a quick API directly from the JSON database (if you used <code>brackets-json-db</code>).</p> Note <p>If you choose to make an API yourself, you can use <code>manager.get.tournamentData()</code> and <code>manager.get.stageData()</code> to retrieve the needed data for the viewer.</p> <p>Once you have something to get data from \u2013 let's assume the result is in a <code>data</code> variable for the example \u2013 you'll be able to render the bracket with <code>window.bracketsViewer.render()</code>:</p> <pre><code>window.bracketsViewer.render({\n    stages: data.stage,\n    matches: data.match,\n    matchGames: data.match_game,\n    participants: data.participant,\n})\n</code></pre> <p>Which would render something like this:</p> <p></p> Fun fact <p>Here, both the manager and the viewer are running client-side! </p>"},{"location":"statistics/","title":"Statistics","text":"<p>Total number of stars: 0</p>"},{"location":"user-guide/calls/","title":"Calls","text":""},{"location":"user-guide/calls/#dynamic-table","title":"Dynamic table","text":""},{"location":"user-guide/calls/#select","title":"<code>select()</code>","text":"<p>Source </p> <pre><code>select(table, filter: Partial&lt;DataTypes[T]&gt;): Promise&lt;DataTypes[T][] | null&gt;\n</code></pre>"},{"location":"user-guide/calls/#stage","title":"Stage","text":""},{"location":"user-guide/calls/#insert","title":"<code>insert()</code>","text":"<p>Source </p> <pre><code>insert('stage', value: OmitId&lt;Stage&gt;): Promise&lt;number&gt;\n</code></pre> <p>Source </p> <pre><code>insert('stage', values: Stage[]): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/calls/#select_1","title":"<code>select()</code>","text":"<p>Source </p> <pre><code>select('stage'): Promise&lt;Stage[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('stage', id: Id): Promise&lt;Stage | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('stage', filter: {\n    tournament_id: Id;\n}): Promise&lt;Stage[] | null&gt;\n</code></pre>"},{"location":"user-guide/calls/#update","title":"<code>update()</code>","text":"<p>Source </p> <pre><code>update('stage', id: Id, value: Stage): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/calls/#delete","title":"<code>delete()</code>","text":"<p>Source </p> <pre><code>delete('stage'): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>delete('stage', filter: {\n    id: Id;\n}): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/calls/#group","title":"Group","text":""},{"location":"user-guide/calls/#selectfirst","title":"<code>selectFirst()</code>","text":"<p>Source </p> <pre><code>selectFirst('group', filter: {\n    stage_id: Id;\n    number: number;\n}): Promise&lt;Group | null&gt;\n</code></pre>"},{"location":"user-guide/calls/#insert_1","title":"<code>insert()</code>","text":"<p>Source </p> <pre><code>insert('group', value: OmitId&lt;Group&gt;): Promise&lt;number&gt;\n</code></pre> <p>Source </p> <pre><code>insert('group', values: Group[]): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/calls/#select_2","title":"<code>select()</code>","text":"<p>Source </p> <pre><code>select('group'): Promise&lt;Group[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('group', id: Id): Promise&lt;Group | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('group', filter: {\n    stage_id: Id;\n}): Promise&lt;Group[] | null&gt;\n</code></pre>"},{"location":"user-guide/calls/#delete_1","title":"<code>delete()</code>","text":"<p>Source </p> <pre><code>delete('group'): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>delete('group', filter: {\n    stage_id: Id;\n}): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/calls/#round","title":"Round","text":""},{"location":"user-guide/calls/#selectlast","title":"<code>selectLast()</code>","text":"<p>Source </p> <pre><code>selectLast('round', filter: {\n    group_id: Id;\n}, assertUnique: false): Promise&lt;Round | null&gt;\n</code></pre>"},{"location":"user-guide/calls/#selectfirst_1","title":"<code>selectFirst()</code>","text":"<p>Source </p> <pre><code>selectFirst('round', filter: {\n    group_id: Id;\n    number: number;\n}): Promise&lt;Round | null&gt;\n</code></pre> <p>Source </p> <pre><code>selectFirst('round', filter: {\n    stage_id: Id;\n    number: number;\n}, assertUnique: false): Promise&lt;Round | null&gt;\n</code></pre>"},{"location":"user-guide/calls/#insert_2","title":"<code>insert()</code>","text":"<p>Source </p> <pre><code>insert('round', value: OmitId&lt;Round&gt;): Promise&lt;number&gt;\n</code></pre> <p>Source </p> <pre><code>insert('round', values: Round[]): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/calls/#select_3","title":"<code>select()</code>","text":"<p>Source </p> <pre><code>select('round'): Promise&lt;Round[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('round', id: Id): Promise&lt;Round | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('round', filter: {\n    stage_id: Id;\n}): Promise&lt;Round[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('round', filter: {\n    group_id: Id;\n}): Promise&lt;Round[] | null&gt;\n</code></pre>"},{"location":"user-guide/calls/#delete_2","title":"<code>delete()</code>","text":"<p>Source </p> <pre><code>delete('round'): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>delete('round', filter: {\n    stage_id: Id;\n}): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/calls/#match","title":"Match","text":""},{"location":"user-guide/calls/#selectfirst_2","title":"<code>selectFirst()</code>","text":"<p>Source </p> <pre><code>selectFirst('match', filter: {\n    round_id: Id;\n    number: number;\n}): Promise&lt;Match | null&gt;\n</code></pre> <p>Source </p> <pre><code>selectFirst('match', filter: {\n    group_id: Id;\n    number: number;\n}): Promise&lt;Match | null&gt;\n</code></pre>"},{"location":"user-guide/calls/#insert_3","title":"<code>insert()</code>","text":"<p>Source </p> <pre><code>insert('match', value: OmitId&lt;Match&gt;): Promise&lt;number&gt;\n</code></pre> <p>Source </p> <pre><code>insert('match', values: Match[]): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/calls/#select_4","title":"<code>select()</code>","text":"<p>Source </p> <pre><code>select('match'): Promise&lt;Match[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('match', id: Id): Promise&lt;Match | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('match', filter: {\n    round_id: Id;\n}): Promise&lt;Match[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('match', filter: {\n    stage_id: Id;\n}): Promise&lt;Match[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('match', filter: {\n    group_id: Id;\n}): Promise&lt;Match[] | null&gt;\n</code></pre>"},{"location":"user-guide/calls/#update_1","title":"<code>update()</code>","text":"<p>Source </p> <pre><code>update('match', id: Id, value: Match): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>update('match', id: Id, value: {\n    id: Id;\n    stage_id: Id;\n    group_id: Id;\n    round_id: Id;\n    number: number;\n    child_count: number;\n    status: Status;\n    opponent1: ParticipantResult | null;\n    opponent2: ParticipantResult | null;\n}): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>update('match', id: Id, value: {\n    child_count: number;\n    id: Id;\n    stage_id: Id;\n    group_id: Id;\n    round_id: Id;\n    number: number;\n    status: Status;\n    opponent1: ParticipantResult | null;\n    opponent2: ParticipantResult | null;\n}): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>update('match', filter: {\n    stage_id: Id;\n}, value: {\n    child_count: number;\n}): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>update('match', filter: {\n    group_id: Id;\n}, value: {\n    child_count: number;\n}): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>update('match', filter: {\n    round_id: Id;\n}, value: {\n    child_count: number;\n}): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/calls/#delete_3","title":"<code>delete()</code>","text":"<p>Source </p> <pre><code>delete('match'): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>delete('match', filter: {\n    stage_id: Id;\n}): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/calls/#match-game","title":"Match game","text":""},{"location":"user-guide/calls/#selectfirst_3","title":"<code>selectFirst()</code>","text":"<p>Source </p> <pre><code>selectFirst('match_game', filter: {\n    parent_id: Id;\n    number: number;\n}): Promise&lt;MatchGame | null&gt;\n</code></pre>"},{"location":"user-guide/calls/#insert_4","title":"<code>insert()</code>","text":"<p>Source </p> <pre><code>insert('match_game', value: {\n    number: number;\n    stage_id: Id;\n    parent_id: Id;\n    status: Status;\n    opponent1: { \n       id: null;\n    };\n    opponent2: { \n       id: null;\n    };\n}): Promise&lt;number&gt;\n</code></pre> <p>Source </p> <pre><code>insert('match_game', value: OmitId&lt;MatchGame&gt;): Promise&lt;number&gt;\n</code></pre> <p>Source </p> <pre><code>insert('match_game', values: MatchGame[]): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/calls/#select_5","title":"<code>select()</code>","text":"<p>Source </p> <pre><code>select('match_game', id: Id): Promise&lt;MatchGame | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('match_game', filter: {\n    parent_id: Id;\n}): Promise&lt;MatchGame[] | null&gt;\n</code></pre>"},{"location":"user-guide/calls/#update_2","title":"<code>update()</code>","text":"<p>Source </p> <pre><code>update('match_game', id: Id, value: MatchGame): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>update('match_game', filter: {\n    parent_id: Id;\n}, value: Partial&lt;MatchGame&gt;): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/calls/#delete_4","title":"<code>delete()</code>","text":"<p>Source </p> <pre><code>delete('match_game'): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>delete('match_game', filter: {\n    parent_id: Id;\n    number: number;\n}): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>delete('match_game', filter: {\n    stage_id: Id;\n}): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/calls/#participant","title":"Participant","text":""},{"location":"user-guide/calls/#insert_5","title":"<code>insert()</code>","text":"<p>Source </p> <pre><code>insert('participant', value: OmitId&lt;Participant&gt;): Promise&lt;number&gt;\n</code></pre> <p>Source </p> <pre><code>insert('participant', values: Participant[]): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>insert('participant', values: OmitId&lt;Participant&gt;[]): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/calls/#select_6","title":"<code>select()</code>","text":"<p>Source </p> <pre><code>select('participant'): Promise&lt;Participant[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('participant', filter: {\n    tournament_id: Id;\n}): Promise&lt;Participant[] | null&gt;\n</code></pre>"},{"location":"user-guide/calls/#delete_5","title":"<code>delete()</code>","text":"<p>Source </p> <pre><code>delete('participant'): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/deleting-data/","title":"Deleting data","text":""},{"location":"user-guide/deleting-data/#about-participant-deletion","title":"About participant deletion","text":"<p>The manager never attempts to delete participants. Participants that were created previously will remain in the database as leftovers (a.k.a. \"tombstones\").  </p> <p>These participants can be reused in the same bracket or in another stage of the same tournament.  </p> <p>This approach avoids accidental data loss and makes it easier to manage participants across multiple stages.</p>"},{"location":"user-guide/deleting-data/#deleting-a-stage","title":"Deleting a stage","text":"<p>Use <code>manager.delete.stage()</code> to delete the given stage and all its components:</p> <ul> <li>Groups</li> <li>Rounds</li> <li>Matches</li> <li>Match games</li> </ul> Warning <p>This does not delete the related participants.</p>"},{"location":"user-guide/deleting-data/#deleting-all-stages-of-a-tournament","title":"Deleting all stages of a tournament","text":"<p>Use <code>manager.delete.tournament()</code> to delete all the stages of the given tournament, and all their components as listed above.</p> Warning <p>This does not delete the related participants, nor the tournament itself.</p> <p>You are responsible for managing the tournaments yourself because as said in the FAQ, the manager doesn't manipulate the tournaments.</p>"},{"location":"user-guide/extra-fields/","title":"Extra fields","text":"<p>You can attach arbitrary metadata (\"extra fields\") to participants and to matches/match games with the manager library.</p>"},{"location":"user-guide/extra-fields/#participants-via-seeding","title":"Participants (via Seeding)","text":"<p>When creating a stage, use <code>Seeding</code> with <code>CustomParticipant</code> objects. Any additional keys you put on those objects are forwarded to storage alongside the required fields.</p> <p>Required participant fields are <code>id</code> and <code>name</code> (<code>tournament_id</code> can be filled automatically).</p> <p>Extra fields are opaque to the manager; they are stored and returned by storage implementations that support arbitrary columns (e.g., JSON or memory). SQL/Prisma backends with fixed schemas may ignore unsupported fields.</p> <p>Example:</p> <pre><code>await manager.create.stage({\n  tournamentId: 1,\n  name: 'Groups',\n  type: 'round_robin',\n  seeding: [\n    { name: 'Alpha', region: 'EU', seed: 1, logoUrl: 'https://\u2026' },\n    { name: 'Bravo', region: 'NA', seed: 2 },\n    { name: 'Charlie', sponsor: 'Acme' },\n    'Delta', // also fine\n  ],\n  settings: { groupCount: 2, seedOrdering: ['groups.effort_balanced'] },\n});\n</code></pre>"},{"location":"user-guide/extra-fields/#matches-and-match-games-via-updates","title":"Matches and match games (via updates)","text":"<p>You can also set extra fields on matches and match games using the update API. The manager merges your fields into stored records while protecting core fields.</p> <p>Reserved fields on matches/games (not overwritten by extra fields):</p> <ul> <li><code>id</code>, <code>number</code>, <code>stage_id</code>, <code>group_id</code>, <code>round_id</code>, <code>status</code>, <code>opponent1</code>, <code>opponent2</code>, <code>child_count</code>, <code>parent_id</code></li> <li>Inside <code>opponent1</code>/<code>opponent2</code>, the reserved keys are: <code>id</code>, <code>score</code>, <code>position</code>, <code>forfeit</code>, <code>result</code></li> </ul> <p>Extra fields are merged into existing records; later updates can overwrite your custom values.</p> <p>The core logic (scores/results/status/propagation) is unaffected by extra fields.</p> <p>Example:</p> <pre><code>// Attach metadata to a match\nawait manager.update.match({\n  id: 123,\n  streamUrl: 'https://twitch.tv/\u2026',\n  venue: 'Main Stage',\n});\n\n// Attach metadata to a match game\nawait manager.update.matchGame({\n  parent_id: 123,\n  number: 2,\n  highlightUrl: 'https://\u2026',\n});\n\n// Update scores and set extra fields in one call\nawait manager.update.match({\n  id: 124,\n  opponent1: { score: 2 },\n  opponent2: { score: 1 },\n  referee: 'Jane Doe',\n  table: 7,\n});\n</code></pre>"},{"location":"user-guide/extra-fields/#retrieval","title":"Retrieval","text":"<p>When you query matches, match games, or participants from storage, any stored extra fields are included in the returned objects.</p> <p>This is subject to your storage backend\u2019s schema and storage implementation.</p>"},{"location":"user-guide/glossary/","title":"Glossary","text":""},{"location":"user-guide/glossary/#stage","title":"Stage","text":"<p>A stage is an intermediate phase in a tournament. Supported stage types are round-robin, single elimination and double elimination.</p>"},{"location":"user-guide/glossary/#group","title":"Group","text":"<p>A group is a logical structure used to group multiple rounds together.</p> <ul> <li>In round-robin stages, a group is a pool.</li> <li>In elimination stages, a group is a bracket.<ul> <li>A single elimination stage can have one or two groups:<ul> <li>The unique bracket.</li> <li>If enabled, the Consolation Final.</li> </ul> </li> <li>A double elimination stage can have two or three groups:<ul> <li>Upper and lower brackets.</li> <li>If enabled, the Grand Final.</li> </ul> </li> </ul> </li> </ul>"},{"location":"user-guide/glossary/#round","title":"Round","text":"<p>A round is a logical structure used to group multiple matches together.</p> <ul> <li>In round-robin stages, a round can be viewed as a day or just as a list of matches that can be played at the same time.</li> <li>In elimination stages, a round is a round of a bracket, e.g. 8th finals, semi-finals, etc.</li> </ul>"},{"location":"user-guide/glossary/#major-minor-round","title":"Major / minor round","text":"<p>In double elimination stages, the lower bracket (LB) alternates between major and minor rounds.</p> <ul> <li>A major round is a regular round. (e.g. LB1, LB3, LB5...)</li> <li>A minor round matches the previous (major) round's winners against upper bracket losers of the corresponding round. (e.g. LB2, LB4, LB6...)</li> </ul>"},{"location":"user-guide/glossary/#match","title":"Match","text":"<p>A match between two participants (more participants are not allowed).</p> <p>Start and end dates or other metadata aren't supported. I believe this is not the purpose of the library, so you'll need to add it on your own.</p>"},{"location":"user-guide/glossary/#match-game","title":"Match game","text":"<p>A match game is a child match for a match. You can have multiple match games in a match.</p> <p>For example, a Best-Of-3 (Bo3) match has 3 match games.</p>"},{"location":"user-guide/glossary/#participant","title":"Participant","text":"<p>A participant can be a team or an individual.</p>"},{"location":"user-guide/glossary/#double-elimination","title":"Double elimination","text":"<p>A double elimination stage is a stage with two brackets: a winner bracket and a loser bracket (sometimes called upper bracket and lower bracket).</p> <p>When players lose in the upper bracket, they have a second chance: they are sent into the lower bracket and can eventually match against the winner of the upper bracket in the Grand Final if they win all their matches in the lower bracket.</p>"},{"location":"user-guide/glossary/#bye","title":"BYE","text":"<p>A BYE is a way to fill blanks in a tournament. You can use them to fill a seeding in order to reach a power of two. The brackets libraries do not support seedings which do not follow a power of two.</p> <p>If a participant does not come at the last minute, you can either replace it with a BYE if the tournament isn't started yet, or forfeit it if the tournament is running.</p> Pro tip <p>You can also have a look at Toornament's documentation, which is very good.</p> <p>The data structure used in the brackets libraries (defined in brackets-model) is heavily inspired by Toornament's API.</p>"},{"location":"user-guide/glossary/#tbd","title":"TBD","text":"<p>TBD means \"To Be Determined\". It's not a BYE, it's just a placeholder for a participant that hasn't been determined yet.</p> <p>It's used when you don't have the participant list yet, or when you want to keep the possibility to add participants later.</p> <p>Technically speaking, here is how it's represented in a match: <pre><code>// The match is not completed yet.\n{\n    \"id\": 1,\n    \"opponent1\": null, // BYE\n    \"opponent2\": {\n        \"id\": null, // TBD\n        \"position\": 2\n    }\n}\n\n// The match is already completed.\n{\n    \"id\": 1,\n    \"opponent1\": null, // BYE\n    \"opponent2\": null, // BYE\n}\n</code></pre></p>"},{"location":"user-guide/glossary/#final-standings","title":"Final Standings","text":"<p>The final standings of a stage is a list of participants sorted by their rank.</p> <p>You can get it with <code>manager.get.finalStandings()</code>.</p> <p>For elimination stages:</p> <ul> <li>The order is determined by the bracket structure: participants that reached the final are at the top of the list.</li> <li>The return value is a list of <code>FinalStandingsItem</code>.</li> </ul> <p>For round-robin stages:</p> <ul> <li>The order is determined by a ranking formula: participants with the highest total points are at the top of the list.</li> <li>The return value is a list of <code>RoundRobinFinalStandingsItem</code>.</li> <li>Match game results (e.g. Bo3) are not taken into account: the parent matches are the source of truth.</li> <li>You can specify the maximum number of participants to qualify per group with the <code>maxQualifiedParticipantsPerGroup</code> option.</li> <li>See How to handle two-stage tournaments? (e.g. round-robin followed by elimination).</li> </ul>"},{"location":"user-guide/glossary/#ranking-formula","title":"Ranking formula","text":"<p>The ranking formula is a function that computes the points of each participant in a round-robin stage in order to rank them in the final standings.</p> <p>It is a function that takes a <code>RankingItem</code> (click for available properties) and returns a number.</p> <p>It can be passed to <code>manager.get.finalStandings()</code> to get the final standings of a round-robin stage. To limit the number of participants that can qualify in each group, use the <code>maxQualifiedParticipantsPerGroup</code> option.</p> <p>The ranking formula is also used by the viewer to display ranking tables below each group of the stage.</p> Hint <p>To avoid confusion, make sure to use the same formula for the manager and the viewer.</p> <p>By default, the viewer uses the following formula:</p> <pre><code>(item) =&gt; 3 * item.wins + 1 * item.draws + 0 * item.losses\n</code></pre> <p>The manager doesn't have a default formula.</p>"},{"location":"user-guide/helpers/","title":"Helpers","text":"<p>This page summarizes the helper utilities exported by the manager library and the convenient Get and Find APIs to retrieve information from the database.</p>"},{"location":"user-guide/helpers/#get-apis","title":"Get APIs","text":"<p>Use <code>manager.get</code> methods to retrieve data that is commonly needed by UIs or automation scripts.</p> <ul> <li><code>manager.get.currentStage()</code>: returns the first stage of the tournament that still has uncompleted matches, or <code>null</code> if all stages are complete.</li> <li><code>manager.get.currentRound()</code>: returns the first round of the stage that still has uncompleted matches, or <code>null</code> if the stage is complete.</li> <li><code>manager.get.currentMatches()</code>: for single elimination, returns the matches that can currently be played in parallel (ready or running). For other stage types, this is not implemented yet.</li> <li><code>manager.get.seeding()</code>: returns the current seeding for the stage with stable seed positions.</li> <li><code>manager.get.stageData()</code> / <code>manager.get.tournamentData()</code>: return a normalized <code>Database</code> snapshot useful for rendering.</li> <li><code>manager.get.matchGames()</code>: fetches all child games for the given parent matches.</li> <li><code>manager.get.finalStandings()</code>: computes the standings at the end of an elimination stage.</li> </ul>"},{"location":"user-guide/helpers/#helper-utilities-exported","title":"Helper utilities (exported)","text":"<p>A non\u2011exhaustive list of helpers exposed for advanced flows:</p> <ul> <li>Round/Match status and utilities: <code>getMatchStatus</code>, <code>isMatchOngoing</code>, <code>isMatchCompleted</code>, <code>isMatchUpdateLocked</code>, <code>hasBye</code>, <code>getWinner</code>, <code>getLoser</code>, <code>getNextSide</code>, <code>getOtherSide</code>, <code>getNextSideLoserBracket</code>, etc.</li> <li>Array helpers: <code>splitBy</code>, <code>splitByParity</code>, <code>makePairs</code>, <code>setArraySize</code>, <code>uniqueBy</code>, <code>getNonNull</code>.</li> <li>Round\u2011robin: <code>makeRoundRobinDistribution</code>, <code>makeRoundRobinMatches</code>, <code>assertRoundRobin</code>.</li> <li>Seeding: <code>balanceByes</code>, <code>convertMatchesToSeeding</code>, <code>sortSeeding</code>, <code>mapParticipants*</code> utilities.</li> <li>Lower\u2011bracket math: <code>isMajorRound</code>, <code>isMinorRound</code>, <code>getUpperBracketRoundCount</code>, <code>getLowerBracketRoundCount</code>, <code>getRoundPairCount</code>, <code>findLoserMatchNumber</code>, etc.</li> </ul>"},{"location":"user-guide/helpers/#finding-the-current-entities","title":"Finding the \u201ccurrent\u201d entities","text":"<p>Common flow to get the current stage and round:</p> <pre><code>const currentStage = await manager.get.currentStage(tournamentId);\nif (!currentStage) {\n  // Tournament completed\n}\n\nconst currentRound = await manager.get.currentRound(currentStage.id);\n</code></pre> <p>You can combine this with <code>helpers.isRoundCompleted(roundMatches)</code> to know if a round is completed.</p>"},{"location":"user-guide/helpers/#getting-all-matches-for-the-next-round","title":"Getting all matches for the next round","text":"<p>To schedule upcoming games, fetch the next round by number and its matches:</p> <pre><code>// Given a current round, load the next round and its matches\nconst nextRound = await storage.selectFirst('round', {\n  stage_id: currentRound.stage_id,\n  number: currentRound.number + 1,\n});\n\nif (nextRound) {\n  const nextMatches = await storage.select('match', { round_id: nextRound.id });\n  // nextMatches contains every match to prepare for the next round\n}\n</code></pre> <p>Notes:</p> <ul> <li>The final of single elimination and the grand final of double elimination are in dedicated groups; make sure you filter by the proper <code>group_id</code> if needed.</li> <li>For parallelization concerns (e.g., only ready matches), combine with <code>helpers.isMatchOngoing(match)</code> or <code>helpers.getMatchStatus(match)</code>.</li> </ul>"},{"location":"user-guide/ordering/","title":"Ordering","text":""},{"location":"user-guide/ordering/#seed-ordering","title":"Seed ordering","text":"<p>Seed ordering controls how the seeding is laid out across matches or groups. In the manager library, you choose methods via <code>settings.seedOrdering</code> when creating a stage, or you can update ordering later with <code>manager.update.ordering()</code> or <code>manager.update.roundOrdering()</code> (before matches start).</p> <p>How many methods to provide:</p> <ul> <li>Round-robin: exactly 1 method and it must start with <code>groups.</code> (used to distribute participants in groups).</li> <li>Single elimination: exactly 1 method (no <code>groups.</code> prefix). It orders seeds in the first round.</li> <li>Double elimination: at least 1 method (no <code>groups.</code> prefix). The indexes in the list correspond to:<ul> <li>Index 0: ordering for upper bracket round 1.</li> <li>Index 1: ordering for losers entering lower bracket round 1.</li> <li>Index 2+: orderings for lower bracket minor rounds (one per minor round).</li> </ul> </li> </ul> <p>If some lower bracket methods are omitted in double elimination, sensible defaults are applied based on the stage size (see Default lower bracket orderings below).</p>"},{"location":"user-guide/ordering/#supported-methods","title":"Supported methods","text":"<ul> <li><code>natural</code>: keep order as-is.</li> <li><code>reverse</code>: reverse the order.</li> <li><code>half_shift</code>: move the second half in front of the first half.</li> <li><code>reverse_half_shift</code>: reverse each half and concatenate.</li> <li><code>pair_flip</code>: swap every pair <code>[1,2, 3,4, \u2026]</code> \u2192 <code>[2,1, 4,3, \u2026]</code>.</li> <li><code>inner_outer</code>: classic bracket layout: 1 vs N, 2 vs N-1, etc. Works for any power-of-two length.</li> <li><code>groups.effort_balanced</code>: spread seeds across groups to balance strengths.</li> <li><code>groups.seed_optimized</code>: \"snake\" distribution per run to minimize early group collisions.</li> <li><code>groups.bracket_optimized</code>: optimized distribution in round-robin groups to avoid bracket-opponents in the same group.<ul> <li>It's a method that ensures that 2 participants playing in the same group will meet at the latest possible point in the bracket.   They will eventually play each other again, probably in the grand finals since they're the best 2 players,   but this method ensures that this meeting happens at the latest round possible.</li> </ul> </li> </ul>"},{"location":"user-guide/ordering/#examples","title":"Examples","text":"<p>Round-robin (2 groups, balanced):</p> <pre><code>await manager.create.stage({\n  tournamentId: 1,\n  name: 'Groups',\n  type: 'round_robin',\n  seeding: ['A','B','C','D','E','F','G','H'],\n  settings: {\n    groupCount: 2,\n    seedOrdering: ['groups.effort_balanced'],\n  },\n});\n</code></pre> <p>Single elimination (standard bracket):</p> <pre><code>await manager.create.stage({\n  tournamentId: 1,\n  name: 'Playoffs',\n  type: 'single_elimination',\n  seeding: ['A','B','C','D','E','F','G','H'],\n  settings: {\n    size: 8,\n    seedOrdering: ['inner_outer'],\n  },\n});\n</code></pre> <p>Double elimination (explicit lower\u2011bracket methods):</p> <pre><code>await manager.create.stage({\n  tournamentId: 1,\n  name: 'DE',\n  type: 'double_elimination',\n  seeding: ['A','B','C','D','E','F','G','H'],\n  settings: {\n    size: 8,\n    seedOrdering: ['inner_outer', 'natural', 'reverse'],\n  },\n});\n</code></pre>"},{"location":"user-guide/ordering/#default-lower-bracket-orderings-double-elimination","title":"Default lower bracket orderings (double elimination)","text":"<p>If you don\u2019t provide enough methods for the lower bracket, defaults are used based on <code>size</code>:</p> <ul> <li>4: <code>['natural', 'reverse']</code></li> <li>8: <code>['natural', 'reverse', 'natural']</code></li> <li>16: <code>['natural', 'reverse_half_shift', 'reverse', 'natural']</code></li> <li>32: <code>['natural', 'reverse', 'half_shift', 'natural', 'natural']</code></li> <li>64: <code>['natural', 'reverse', 'half_shift', 'reverse', 'natural', 'natural']</code></li> <li>128: <code>['natural', 'reverse', 'half_shift', 'pair_flip', 'pair_flip', 'pair_flip', 'natural']</code></li> </ul> <p>Index 0 is used for the first lower bracket round (WB losers entering), then indices 1+ are used for minor rounds in order.</p> Default lower bracket ordering is only provided for tournament sizes up to 128 participants. <p>For sizes of 256 and more, all rounds will default to a <code>natural</code> ordering. To override this, you must specify your own list using the <code>seedOrdering</code> setting.</p> <p>You can also update ordering after creation, as said in Updating ordering after creation.</p>"},{"location":"user-guide/ordering/#updating-ordering-after-creation","title":"Updating ordering after creation","text":"<p>You can update ordering before matches begin:</p> <ul> <li>Per stage with <code>manager.update.ordering()</code>: update all rounds at once (fails if any affected match has started or completed).</li> <li>Per round with <code>manager.update.roundOrdering()</code>: update a specific round.</li> </ul> <p>For elimination stages, only rounds that support ordering can be updated (upper bracket round 1; lower bracket round 1 and minor rounds).</p>"},{"location":"user-guide/seeding/","title":"Seeding","text":""},{"location":"user-guide/seeding/#what-is-a-seeding","title":"What is a seeding?","text":"<p>In tournaments and brackets, a seeding is the ordered list of participants that defines who starts where in the competition. The order matters: it drives initial pairings and, with an ordering method, how participants are distributed across rounds or groups.</p> <ul> <li>BYEs: Empty slots used to reach a valid bracket size. They advance opponents automatically when paired against someone.   You can use BYEs to fill a seeding in order to reach a power of two. The manager library does not support seedings not following a power of two for elimination stages. For round-robin stages, any size \u2265 2 is supported.</li> </ul>"},{"location":"user-guide/seeding/#seeding-in-the-manager-library","title":"Seeding in the manager library","text":"<p>The manager library accepts a seeding in multiple forms when creating a stage. You can:</p> <ul> <li>Provide a full seeding list.</li> <li>Or provide only a <code>size</code> (number of participants) to create a stage with TBD slots.</li> </ul> <p>Rules by stage type:</p> <ul> <li>Round-robin: Any size \u2265 2 is supported.</li> <li>Single/double elimination: Size must be a power of two (2, 4, 8, 16, ...). Use BYEs (<code>null</code>) to pad to the next power of two if needed.</li> </ul> <p>Useful stage settings related to seeding when using <code>manager.create.stage()</code>:</p> <ul> <li><code>settings.seedOrdering</code>: How seeds are laid out (per stage type). See the ordering guide.</li> <li><code>settings.balanceByes</code> (elimination): Avoids BYE vs. BYE matches when padding with BYEs.</li> </ul>"},{"location":"user-guide/seeding/#the-seeding-types","title":"The Seeding types","text":""},{"location":"user-guide/seeding/#seeding","title":"<code>Seeding</code>","text":"<p><sub><code>(CustomParticipant | string | number | null)[]</code></sub></p> <p>Each participant of the list can either be:</p> <ul> <li>A <code>CustomParticipant</code> object (may include extra fields, see Attaching extra fields.)</li> <li>A string, corresponding to its <code>name</code></li> <li>A number, corresponding to its <code>id</code></li> <li>A BYE (<code>null</code>)</li> </ul> <p>If you include numbers, they are treated as IDs, and must already exist in the <code>participant</code> table for the corresponding <code>tournament_id</code>.</p> <p>If you give names/objects, participants are automatically added to the <code>participant</code> table.</p>"},{"location":"user-guide/seeding/#idseeding","title":"<code>IdSeeding</code>","text":"<p><sub><code>(Id | null)[]</code></sub></p> <ul> <li>IDs or BYEs only. Participants must already exist in storage for the corresponding <code>tournament_id</code>.</li> </ul>"},{"location":"user-guide/seeding/#difference-between-seeding-and-idseeding","title":"Difference between <code>Seeding</code> and <code>IdSeeding</code>:","text":"<ul> <li><code>Seeding</code> is flexible (names, objects, IDs, BYEs) and can automatically register participants.</li> <li><code>IdSeeding</code> is strict (IDs, BYEs) and never registers participants.</li> </ul> <p>Since <code>Seeding</code> assumes <code>string</code> values are names and <code>number</code> values are IDs, you must use <code>IdSeeding</code> if you are working with string IDs e.g. with a MongoDB database.</p>"},{"location":"user-guide/seeding/#using-seeding-with-managercreatestage","title":"Using seeding with <code>manager.create.stage()</code>","text":"<p>Below are minimal examples. Adjust <code>settings</code> depending on the stage type.</p> Notes <ul> <li>For elimination stages, ensure <code>size</code> is a power of two, or provide a seeding padded with BYEs to reach one.</li> <li>When mixing types in <code>Seeding</code>, duplicates are rejected, and the list is expanded with BYEs if shorter than <code>settings.size</code>.</li> </ul>"},{"location":"user-guide/seeding/#1-seeding-by-names-auto-registers-participants","title":"1) Seeding by names (auto-registers participants)","text":"<pre><code>await manager.create.stage({\n  tournamentId: 1,\n  name: 'Quarter Finals',\n  type: 'single_elimination',\n  seeding: ['Alice', 'Bob', 'Carol', 'Dave', 'Eve', 'Frank', null, null],\n  settings: {\n    size: 8,\n    seedOrdering: ['inner_outer'],\n    balanceByes: true,\n  },\n});\n</code></pre>"},{"location":"user-guide/seeding/#2-seeding-by-objects-with-extra-fields","title":"2) Seeding by objects (with extra fields)","text":"<pre><code>await manager.create.stage({\n  tournamentId: 1,\n  name: 'Groups',\n  type: 'round_robin',\n  seeding: [\n    { id: 10, name: 'Alpha', region: 'EU' },\n    { name: 'Bravo', region: 'NA' },\n    'Charlie',\n    'Delta',\n  ],\n  settings: {\n    groupCount: 2,\n    seedOrdering: ['groups.effort_balanced'],\n  },\n});\n</code></pre>"},{"location":"user-guide/seeding/#3-seeding-by-ids-participants-must-already-exist","title":"3) Seeding by IDs (participants must already exist)","text":"<pre><code>await manager.create.stage({\n  tournamentId: 1,\n  name: 'Playoffs',\n  type: 'double_elimination',\n  seedingIds: [1, 2, 3, 4, 5, 6, null, null],\n  settings: {\n    size: 8,\n    seedOrdering: ['inner_outer', 'natural'],\n    balanceByes: true,\n    grandFinal: 'simple',\n  },\n});\n</code></pre>"},{"location":"user-guide/seeding/#4-provide-only-a-size-create-tbd-slots","title":"4) Provide only a size (create TBD slots)","text":"<p>If you don't have the participant list yet, you can give only a size. This creates a bracket with TBD slots (<code>id: null</code>) that you can fill later.</p> <pre><code>await manager.create.stage({\n  tournamentId: 1,\n  name: 'Open Bracket',\n  type: 'single_elimination',\n  settings: {\n    size: 16,\n    seedOrdering: ['inner_outer'],\n  },\n});\n</code></pre>"},{"location":"user-guide/seeding/#updating-seeding","title":"Updating seeding","text":"<p>You can update the seeding of a stage with <code>manager.update.seeding()</code>.</p> <pre><code>await manager.update.seeding(stageId, seeding, [keepSameSize]);\n</code></pre> <p>If the new seeding is shorter than the previous one, unless you set <code>keepSameSize</code> to <code>true</code>, the seeding will be shrunk to the new size.</p> Info <p>If a seeding shrinks in size, the participants won't be deleted. See About participant deletion.</p> <p>In the context of updating the seeding, a <code>null</code> value in <code>Seeding</code> is treated as a TBD instead of a BYE because we consider the tournament might have been started. If it's not and you prefer BYEs, you should recreate the stage from scratch.</p> <p>As long as the seeding update does not impact existing results, it is allowed.</p>"},{"location":"user-guide/seeding/#confirming-seeding","title":"Confirming seeding","text":"<p>You can confirm the seeding of a stage with <code>manager.update.confirmSeeding()</code>.</p> <pre><code>await manager.update.confirmSeeding(stageId);\n</code></pre> <p>This will convert TBDs to BYEs and propagate them. Implemented in #131.</p>"},{"location":"user-guide/seeding/#resetting-seeding","title":"Resetting seeding","text":"<p>You can reset the seeding of a stage with <code>manager.reset.seeding()</code>.</p> <pre><code>await manager.reset.seeding(stageId);\n</code></pre> <p>This will reset the seeding to an empty seeding, with all match opponents set to TBDs.</p>"},{"location":"user-guide/storage/","title":"Storage","text":"Info <p>This page is automatically generated using <code>brackets-storage-calls</code>.</p> <p>To be compatible with every kind of storage, the manager is designed to use dependency injection, thanks to the <code>CrudInterface</code> implementation your are passing to its constructor.</p> <p>The <code>brackets-storage</code> repository provides implementations for some storages:</p> Package brackets-json-db brackets-memory-db brackets-prisma-db <p>If there is no implementation for the storage you want to use, you will have to implement it yourself...</p> <p>As it can be hard to do with something like a SQL database, this page shows every usage of the CRUD interface by the manager so you don't have to read all the manager code.</p> Tip <p>Once you have your implementation up and running, consider opening a PR on brackets-storage to share your work with the community! </p>"},{"location":"user-guide/storage/#dynamic-table","title":"Dynamic table","text":""},{"location":"user-guide/storage/#select","title":"<code>select()</code>","text":"<p>Source </p> <pre><code>select(table, filter: Partial&lt;DataTypes[T]&gt;): Promise&lt;DataTypes[T][] | null&gt;\n</code></pre>"},{"location":"user-guide/storage/#stage","title":"Stage","text":""},{"location":"user-guide/storage/#insert","title":"<code>insert()</code>","text":"<p>Source </p> <pre><code>insert('stage', value: OmitId&lt;Stage&gt;): Promise&lt;number&gt;\n</code></pre> <p>Source </p> <pre><code>insert('stage', values: Stage[]): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/storage/#select_1","title":"<code>select()</code>","text":"<p>Source </p> <pre><code>select('stage'): Promise&lt;Stage[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('stage', id: Id): Promise&lt;Stage | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('stage', filter: {\n    tournament_id: Id;\n}): Promise&lt;Stage[] | null&gt;\n</code></pre>"},{"location":"user-guide/storage/#update","title":"<code>update()</code>","text":"<p>Source </p> <pre><code>update('stage', id: Id, value: Stage): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/storage/#delete","title":"<code>delete()</code>","text":"<p>Source </p> <pre><code>delete('stage'): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>delete('stage', filter: {\n    id: Id;\n}): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/storage/#group","title":"Group","text":""},{"location":"user-guide/storage/#selectfirst","title":"<code>selectFirst()</code>","text":"<p>Source </p> <pre><code>selectFirst('group', filter: {\n    stage_id: Id;\n    number: number;\n}): Promise&lt;Group | null&gt;\n</code></pre>"},{"location":"user-guide/storage/#insert_1","title":"<code>insert()</code>","text":"<p>Source </p> <pre><code>insert('group', value: OmitId&lt;Group&gt;): Promise&lt;number&gt;\n</code></pre> <p>Source </p> <pre><code>insert('group', values: Group[]): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/storage/#select_2","title":"<code>select()</code>","text":"<p>Source </p> <pre><code>select('group'): Promise&lt;Group[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('group', id: Id): Promise&lt;Group | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('group', filter: {\n    stage_id: Id;\n}): Promise&lt;Group[] | null&gt;\n</code></pre>"},{"location":"user-guide/storage/#delete_1","title":"<code>delete()</code>","text":"<p>Source </p> <pre><code>delete('group'): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>delete('group', filter: {\n    stage_id: Id;\n}): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/storage/#round","title":"Round","text":""},{"location":"user-guide/storage/#selectlast","title":"<code>selectLast()</code>","text":"<p>Source </p> <pre><code>selectLast('round', filter: {\n    group_id: Id;\n}, assertUnique: false): Promise&lt;Round | null&gt;\n</code></pre>"},{"location":"user-guide/storage/#selectfirst_1","title":"<code>selectFirst()</code>","text":"<p>Source </p> <pre><code>selectFirst('round', filter: {\n    group_id: Id;\n    number: number;\n}): Promise&lt;Round | null&gt;\n</code></pre> <p>Source </p> <pre><code>selectFirst('round', filter: {\n    stage_id: Id;\n    number: number;\n}, assertUnique: false): Promise&lt;Round | null&gt;\n</code></pre>"},{"location":"user-guide/storage/#insert_2","title":"<code>insert()</code>","text":"<p>Source </p> <pre><code>insert('round', value: OmitId&lt;Round&gt;): Promise&lt;number&gt;\n</code></pre> <p>Source </p> <pre><code>insert('round', values: Round[]): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/storage/#select_3","title":"<code>select()</code>","text":"<p>Source </p> <pre><code>select('round'): Promise&lt;Round[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('round', id: Id): Promise&lt;Round | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('round', filter: {\n    stage_id: Id;\n}): Promise&lt;Round[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('round', filter: {\n    group_id: Id;\n}): Promise&lt;Round[] | null&gt;\n</code></pre>"},{"location":"user-guide/storage/#delete_2","title":"<code>delete()</code>","text":"<p>Source </p> <pre><code>delete('round'): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>delete('round', filter: {\n    stage_id: Id;\n}): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/storage/#match","title":"Match","text":""},{"location":"user-guide/storage/#selectfirst_2","title":"<code>selectFirst()</code>","text":"<p>Source </p> <pre><code>selectFirst('match', filter: {\n    round_id: Id;\n    number: number;\n}): Promise&lt;Match | null&gt;\n</code></pre> <p>Source </p> <pre><code>selectFirst('match', filter: {\n    group_id: Id;\n    number: number;\n}): Promise&lt;Match | null&gt;\n</code></pre>"},{"location":"user-guide/storage/#insert_3","title":"<code>insert()</code>","text":"<p>Source </p> <pre><code>insert('match', value: OmitId&lt;Match&gt;): Promise&lt;number&gt;\n</code></pre> <p>Source </p> <pre><code>insert('match', values: Match[]): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/storage/#select_4","title":"<code>select()</code>","text":"<p>Source </p> <pre><code>select('match'): Promise&lt;Match[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('match', id: Id): Promise&lt;Match | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('match', filter: {\n    round_id: Id;\n}): Promise&lt;Match[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('match', filter: {\n    stage_id: Id;\n}): Promise&lt;Match[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('match', filter: {\n    group_id: Id;\n}): Promise&lt;Match[] | null&gt;\n</code></pre>"},{"location":"user-guide/storage/#update_1","title":"<code>update()</code>","text":"<p>Source </p> <pre><code>update('match', id: Id, value: Match): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>update('match', id: Id, value: {\n    id: Id;\n    stage_id: Id;\n    group_id: Id;\n    round_id: Id;\n    number: number;\n    child_count: number;\n    status: Status;\n    opponent1: ParticipantResult | null;\n    opponent2: ParticipantResult | null;\n}): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>update('match', id: Id, value: {\n    child_count: number;\n    id: Id;\n    stage_id: Id;\n    group_id: Id;\n    round_id: Id;\n    number: number;\n    status: Status;\n    opponent1: ParticipantResult | null;\n    opponent2: ParticipantResult | null;\n}): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>update('match', filter: {\n    stage_id: Id;\n}, value: {\n    child_count: number;\n}): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>update('match', filter: {\n    group_id: Id;\n}, value: {\n    child_count: number;\n}): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>update('match', filter: {\n    round_id: Id;\n}, value: {\n    child_count: number;\n}): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/storage/#delete_3","title":"<code>delete()</code>","text":"<p>Source </p> <pre><code>delete('match'): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>delete('match', filter: {\n    stage_id: Id;\n}): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/storage/#match-game","title":"Match game","text":""},{"location":"user-guide/storage/#selectfirst_3","title":"<code>selectFirst()</code>","text":"<p>Source </p> <pre><code>selectFirst('match_game', filter: {\n    parent_id: Id;\n    number: number;\n}): Promise&lt;MatchGame | null&gt;\n</code></pre>"},{"location":"user-guide/storage/#insert_4","title":"<code>insert()</code>","text":"<p>Source </p> <pre><code>insert('match_game', value: {\n    number: number;\n    stage_id: Id;\n    parent_id: Id;\n    status: Status;\n    opponent1: { \n       id: null;\n    };\n    opponent2: { \n       id: null;\n    };\n}): Promise&lt;number&gt;\n</code></pre> <p>Source </p> <pre><code>insert('match_game', value: OmitId&lt;MatchGame&gt;): Promise&lt;number&gt;\n</code></pre> <p>Source </p> <pre><code>insert('match_game', values: MatchGame[]): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/storage/#select_5","title":"<code>select()</code>","text":"<p>Source </p> <pre><code>select('match_game', id: Id): Promise&lt;MatchGame | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('match_game', filter: {\n    parent_id: Id;\n}): Promise&lt;MatchGame[] | null&gt;\n</code></pre>"},{"location":"user-guide/storage/#update_2","title":"<code>update()</code>","text":"<p>Source </p> <pre><code>update('match_game', id: Id, value: MatchGame): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>update('match_game', filter: {\n    parent_id: Id;\n}, value: Partial&lt;MatchGame&gt;): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/storage/#delete_4","title":"<code>delete()</code>","text":"<p>Source </p> <pre><code>delete('match_game'): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>delete('match_game', filter: {\n    parent_id: Id;\n    number: number;\n}): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>delete('match_game', filter: {\n    stage_id: Id;\n}): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/storage/#participant","title":"Participant","text":""},{"location":"user-guide/storage/#insert_5","title":"<code>insert()</code>","text":"<p>Source </p> <pre><code>insert('participant', value: OmitId&lt;Participant&gt;): Promise&lt;number&gt;\n</code></pre> <p>Source </p> <pre><code>insert('participant', values: Participant[]): Promise&lt;boolean&gt;\n</code></pre> <p>Source </p> <pre><code>insert('participant', values: OmitId&lt;Participant&gt;[]): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/storage/#select_6","title":"<code>select()</code>","text":"<p>Source </p> <pre><code>select('participant'): Promise&lt;Participant[] | null&gt;\n</code></pre> <p>Source </p> <pre><code>select('participant', filter: {\n    tournament_id: Id;\n}): Promise&lt;Participant[] | null&gt;\n</code></pre>"},{"location":"user-guide/storage/#delete_5","title":"<code>delete()</code>","text":"<p>Source </p> <pre><code>delete('participant'): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"user-guide/structure/","title":"Structure","text":"<p>This page explains the structure of a tournament in more details. For the basis, read the Glossary.</p>"},{"location":"user-guide/structure/#round-robin","title":"Round-robin","text":"<p>In round-robin stages, each group is a pool, which contains rounds, which contain matches.</p>"},{"location":"user-guide/structure/#single-elimination","title":"Single elimination","text":"<p>In single elimination stages, there is at least one group (the \"unique bracket\"), which contains rounds, which contain matches.</p> <p>The unique bracket yields a winner, and losers.</p> <p>If the stage is configured to have a consolation final, it is also a group with a single round containing a single match, matching both semi-final losers.</p>"},{"location":"user-guide/structure/#double-elimination","title":"Double elimination","text":"<p>In double elimination stages, there are two groups: the upper bracket (a.k.a. \"winner bracket\") and the lower bracket (a.k.a. \"loser bracket\").</p> <p>The upper bracket yields a winner, and losers.</p> <p>The lower bracket yields a winner, which may play in the grand final against the winner of the upper bracket.</p> <p>If the stage is configured to have a grand final, it is also a group with one or two rounds (depending on <code>settings.grandFinal</code>), each containing a single match, matching the winner of the upper bracket and the winner of the lower bracket.</p> <p>If the WB winner wins, he's the winner of the stage. But if he loses, the final is reset and there is a very last match. It might be fairer since it gives the WB winner the right to lose once during the stage...</p> <p>If the stage is configured to have a consolation final, any existing final group is reused (i.e. the grand final and consolation final will both be in the final group). In this group, a round is created containing a single match, matching both upper bracket semi-final losers.</p> Technical detail about the consolation final <p>To differentiate the grand final and consolation final matches which always are <code>number: 1</code>, the consolation final match is <code>number: 2</code> although it's the only match in its round.</p>"},{"location":"user-guide/structure/#opponent-position-property-in-matches","title":"Opponent <code>position</code> property in matches","text":"<p>The <code>position</code> property in <code>opponent1</code> and <code>opponent2</code> in a match is used to display the opponent's origin in the UI.</p> <p>It holds the match number of the match whose winner will fill the current participant slot in the match.</p> <p>For example, the match <code>LB 1.1</code> (loser bracket, round 1, match 1) has the following values: <pre><code>{\n    \"opponent1\": {\n        \"id\": null, // TBD\n        \"position\": 1\n    },\n    \"opponent2\": {\n        \"id\": null, // TBD\n        \"position\": 2\n    }\n}\n</code></pre></p> <p>Although we don't know the opponent IDs yet, we know their source in advance. So in the UI, we show:</p> LB 1.1 Opponents <code>opponent1</code> Loser of WB 1.1 <code>opponent2</code> Loser of WB 1.2"},{"location":"user-guide/updating-matches/","title":"Updating matches","text":"<p>This page explains how to update matches and match games with the manager library, and what the library does for you behind the scenes.</p> <p>The library only lets you update matches one by one, because it is intended to be used on an event basis, when a tournament is running.</p>"},{"location":"user-guide/updating-matches/#concepts-recap","title":"Concepts recap","text":"<ul> <li><code>Match</code>: the parent entity. It can optionally contain several child games when using Best\u2011of\u2011X.</li> <li><code>MatchGame</code>: a child game belonging to a parent match. Their scores determine the parent match result.</li> <li><code>Status</code>: <code>Locked</code> (0) &gt; <code>Waiting</code> (1) &gt; <code>Ready</code> (2) &gt; <code>Running</code> (3) &gt; <code>Completed</code> (4) &gt; <code>Archived</code> (5)</li> </ul>"},{"location":"user-guide/updating-matches/#update-a-match","title":"Update a match","text":"<p>Use the updater to change partial fields of a match by id. The library validates input, infers results, and propagates effects.</p> <pre><code>// Only sets the scores without setting the results or status\nawait manager.update.match({\n  id: 42,\n  opponent1: { score: 3 },\n  opponent2: { score: 1 },\n});\n</code></pre> <p>In this other example, the result and status are set.</p> <pre><code>// The second opponent's result is inferred, as well as the status.\nawait manager.update.match({\n  id: 42,\n  opponent1: { score: 3, result: 'win' },\n  opponent2: { score: 1 },\n});\n</code></pre> <p>What happens:</p> <ul> <li>Result inference: sets win/loss (and draw in round\u2011robin) from scores or forfeits.</li> <li>BYEs handling: auto\u2011wins when facing a BYE, keeps BYE/TBD semantics.</li> <li>Status recompute: status is recomputed consistently from the provided fields.</li> <li>Propagation: winners/losers are sent to their next matches; next matches get their status updated accordingly.</li> </ul> <p>Constraints:</p> <ul> <li>In elimination stages, draws are forbidden.</li> <li>For matches with status <code>Locked</code>, <code>Waiting</code>, <code>Archived</code>, or auto\u2011completed by BYEs: nothing is editable (updates are rejected)</li> <li>For matches with status <code>Running</code> or <code>Completed</code>: only the scores, results, forfeits, and status are editable. You cannot change <code>opponent*.id</code> or <code>opponent*.position</code> nor replace participants.</li> </ul> <p>However, for more flexibility, if your match looks like this:</p> <pre><code>{\n  \"id\": 42,\n  \"opponent1\": { \"id\": 0 },\n  \"opponent2\": { \"id\": 1 }\n}\n</code></pre> <p>It's possible to \"query\" by ID in the partial update:</p> <pre><code>await manager.update.match({\n  id: 42,\n  opponent1: { id: 1, score: 3 },\n  opponent2: { id: 0, score: 1 },\n});\n\n// Result:\n{\n  \"id\": 42,\n  \"opponent1\": { \"id\": 0, \"score\": 1 }, // The position in the match is **unchanged**\n  \"opponent2\": { \"id\": 1, \"score\": 3 }\n}\n</code></pre>"},{"location":"user-guide/updating-matches/#update-a-match-game-bestofx","title":"Update a match game (Best\u2011of\u2011X)","text":"<p>Child games update the parent match automatically.</p> <pre><code>await manager.update.matchGame({\n  id: 101,\n  opponent1: { score: 1 },\n  opponent2: { score: 0 },\n});\n</code></pre> <p>What happens:</p> <ul> <li>Scores across child games are aggregated.</li> <li>When a side reaches the minimum to win <code>ceil((X+1)/2)</code> for a Best\u2011of\u2011<code>X</code> match, the parent match gets marked as completed.</li> <li>If child games lead to an impossible tie in elimination, an error is thrown.</li> </ul>"},{"location":"user-guide/updating-matches/#adjust-bestofx-for-existing-matches","title":"Adjust Best\u2011of\u2011X for existing matches","text":"<p>You can change the child game count on every level. The library inserts/deletes games and keeps numbering consistent.</p> <pre><code>// for a whole stage\nawait manager.update.matchChildCount('stage', stageId, 1);\n\n// for a whole group\nawait manager.update.matchChildCount('group', groupId, 2);\n\n// for a whole round\nawait manager.update.matchChildCount('round', roundId, 3);\n\n// for a single match\nawait manager.update.matchChildCount('match', matchId, 4);\n</code></pre>"},{"location":"user-guide/updating-matches/#forfeits","title":"Forfeits","text":"<p>You can mark a side as forfeited. The opponent is awarded the win; a double forfeit yields no result in round\u2011robin.</p> <pre><code>await manager.update.match({\n  id: 42,\n  opponent1: { forfeit: true },\n});\n</code></pre>"},{"location":"user-guide/updating-matches/#tips","title":"Tips","text":"<ul> <li>Update matches before their dependents start to avoid cascading constraints.</li> <li>Prefer updating child games when using Best\u2011of\u2011X; let the library compute the parent outcome.</li> <li>Use Extra fields to store user-specific metadata; they are passed through on updates.</li> </ul>"}]}